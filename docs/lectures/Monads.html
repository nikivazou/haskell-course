<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CMSC498V - Monads</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../index.html">Home</a>
                <a href="../schedule.html">Schelude</a>
                <a href="../homeworks.html">Homeworks</a>
                <a href="../resources.html">Resources</a>
            </div>
        </div>

        <div id="content">
            <h1 id="monads">Monads</h1>
<p>After Monoids, Applicatives and Functors, we are ready to learn what Monads are. But, instead of starting with the monadic class definition, let’s start by an example that is actually using monads in a hidden way.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Monads</span> <span class="kw">where</span>
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Control.Monad.State.Lazy</span> <span class="kw">as</span> <span class="dt">ST</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.State.Lazy</span> <span class="kw">hiding</span> (<span class="dt">State</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Map</span> <span class="kw">hiding</span> (lookup)</code></pre></div>
<h2 id="a-simple-evaluator">A Simple Evaluator</h2>
<p>Consider the following simple language of expressions that are built up from integer values using a division operator:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Div</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
<span class="ot">&gt;</span>           <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>Such expressions can be evaluated as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eval1              ::</span>  <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> eval1 (<span class="dt">Val</span> n)     <span class="fu">=</span>  n
<span class="ot">&gt;</span> eval1 (<span class="dt">Div</span> x y)   <span class="fu">=</span>  eval1 x <span class="ot">`div`</span> eval1 y</code></pre></div>
<p>However, this function doesn’t take account of the possibility of division by zero, and will produce an error in this case.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> eval (<span class="dt">Div</span> (<span class="dt">Val</span> <span class="dv">1</span>) (<span class="dt">Val</span> <span class="dv">0</span>))
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> divide by zero </code></pre></div>
<p>In order to deal with this explicitly, we can use the <code>Maybe</code> type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</code></pre></div>
<p>to define a safe version of division</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; safeDiv     ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> safeDiv n m <span class="fu">=</span>  <span class="kw">if</span> m <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (n <span class="ot">`div`</span> m)</code></pre></div>
<p>and then modify our evaluator as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Exception</span> a <span class="fu">=</span> <span class="dt">Maybe</span> a 
<span class="ot">&gt;</span> 
<span class="ot">&gt; eval1' ::</span>  <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Exception</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> eval1' (<span class="dt">Val</span> n)   <span class="fu">=</span>  <span class="dt">Just</span> n
<span class="ot">&gt;</span> eval1' (<span class="dt">Div</span> x y) <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   n1 <span class="ot">&lt;-</span> eval1' x
<span class="ot">&gt;</span>   n2 <span class="ot">&lt;-</span> eval1' y 
<span class="ot">&gt;</span>   n1 <span class="ot">`safeDiv`</span> n2</code></pre></div>
<p><strong>Q:</strong> What happens now to our previous exception?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> eval1' (<span class="dt">Div</span> (<span class="dt">Val</span> <span class="dv">1</span>) (<span class="dt">Val</span> <span class="dv">0</span>))</code></pre></div>
<p><strong>Goal:</strong> Simplify <code>eval1'</code>. Let’s try to use the fact that <code>Maybe</code> is an applicative to simplify the definition of <code>eval1'</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot"> eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
 eval (<span class="dt">Val</span> n)   <span class="fu">=</span> pure n
 eval (<span class="dt">Div</span> x y) <span class="fu">=</span> pure safeDiv <span class="fu">&lt;*&gt;</span> eval x <span class="fu">&lt;*&gt;</span> eval y</code></pre></div>
<p>We are in a good direction, but the above does not type check… <code>safediv</code> has type <code>Int -&gt; Int -&gt; Maybe Int</code>, whereas in the above context a function of type <code>Int -&gt; Int -&gt; Int</code> is required. Replacing <code>pure safediv</code> by another function would not help either, because this function would need to have type <code>Maybe (Int -&gt; Int -&gt; Int)</code>, which does not provide any means to indicate failure when the second integer argument is zero.</p>
<p>So, <code>eval</code> does not fit the pattern of effectful programming that is captured by applicative functors. They both treat <code>Maybe</code> to indicate <em>failure</em>, yet, applicatives reason about <em>pure</em> functions, while <code>safeDiv</code> observes failure <em>depending</em> on its arguments.</p>
<p>To simplify the nested tuples in <code>eval</code> let’s abstact away the common pattern that</p>
<ul>
<li>performs a case analysis on a value of a <code>Maybe</code> type,</li>
<li>maps <code>Nothing</code> to <code>Nothing</code>, and</li>
<li>maps <code>Just x</code> to some result depending upon <code>x</code>.</li>
</ul>
<p>Abstract this pattern directly gives a new sequencing operator that we write as <code>(&gt;&gt;=)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=)   ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
m <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span>  <span class="kw">case</span> m <span class="kw">of</span>
             <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
             <span class="dt">Just</span> x  <span class="ot">-&gt;</span> f x</code></pre></div>
<p>Replacing the use of case analysis by pattern matching gives a more compact definition for this operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=)          ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="dt">Nothing</span>
(<span class="dt">Just</span> x) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</code></pre></div>
<p>That is, if the first argument is <code>Nothing</code> then the second argument is ignored and <code>Nothing</code> is returned as the result. Otherwise, if the first argument is of the form <code>Just x</code>, then the second argument is applied to <code>x</code> to give a result of type <code>Maybe b</code>.</p>
<p>The <code>(&gt;&gt;=)</code> operator avoids the problem of nested tuples of results because the result of the first argument is made directly available for processing by the second, rather than being paired up with the second result to be processed later on. In this manner, <code>(&gt;&gt;=)</code> integrates the sequencing of values of type <code>Maybe</code> with the processing of their result values. The function <code>(&gt;&gt;=)</code> is read as <strong>bind</strong> because is nothing fails, the second argument binds the result of the first.</p>
<p>Using <code>(&gt;&gt;=)</code>, our evaluator can now be rewritten as:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> eval (<span class="dt">Val</span> n)   <span class="fu">=</span> <span class="dt">Just</span> n
<span class="ot">&gt;</span> eval (<span class="dt">Div</span> x y) <span class="fu">=</span> eval x <span class="fu">&gt;&gt;=</span> (\n <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>                    eval y <span class="fu">&gt;&gt;=</span> (\m <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>                      safeDiv n m
<span class="ot">&gt;</span>                    )
<span class="ot">&gt;</span>                  )</code></pre></div>
<p>The case for division can be read as follows: evaluate <code>x</code> and call its result value <code>n</code>, then evaluate <code>y</code> and call its result value <code>m</code>, and finally combine the two results by applying <code>safeDiv</code>. In fact, the scoping rules for lambda expressions mean that the parentheses in the case for division can freely be omitted.</p>
<p>Generalising from this example, a typical expression built using the <code>(&gt;&gt;=)</code> operator has the following structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">m1 <span class="fu">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span>
m2 <span class="fu">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span>
<span class="fu">...</span>
mn <span class="fu">&gt;&gt;=</span> \xn <span class="ot">-&gt;</span>
f x1 x2 <span class="fu">...</span> xn</code></pre></div>
<p>&lt; do &lt; x1 &lt;- m1 &lt; let y1 = a1 px[ …x2..] ~~&gt; ERROR<br />
&lt; x2 &lt;- m2 &lt; … &lt; xn &lt;- mn &lt; f x1 x2 … xn where w1 = … foo w2 …. w2 = … w3 w3 = …</p>
<p>That is, evaluate each of the expression <code>m1</code>, <code>m2</code>,…,<code>mn</code> in turn, and combine their result values <code>x1</code>, <code>x2</code>,…, <code>x</code>n by applying the function <code>f</code>. The definition of <code>(&gt;&gt;=)</code> ensures that such an expression only succeeds (returns a value built using <code>Just</code>) if each <code>mi</code> in the sequence succeeds.</p>
<p>In other words, the programmer does not have to worry about dealing with the possible failure (returning <code>Nothing</code>) of any of the component expressions, as this is handled automatically by the <code>(&gt;&gt;=)</code> operator.</p>
<p>Haskell provides a special notation for expressions of the above structure, allowing them to be written in a more appealing form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> x1 <span class="ot">&lt;-</span> m1
   x2 <span class="ot">&lt;-</span> m2
   <span class="fu">...</span>
   xn <span class="ot">&lt;-</span> mn
   f x1 x2 <span class="fu">...</span> xn</code></pre></div>
<p>This is the same notation that is also used for programming with <code>IO</code>. As in this setting, each item in the sequence must begin in the same column, and <code>xi &lt;- mi</code> can be abbreviated by <code>mi</code> if its result value xi is not required.</p>
<p>Hence, for example, our evaluator can be redefined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">eval (<span class="dt">Val</span> n)   <span class="fu">=</span> <span class="dt">Just</span> n
eval (<span class="dt">Div</span> x y) <span class="fu">=</span> <span class="kw">do</span> n <span class="ot">&lt;-</span> eval x
                    m <span class="ot">&lt;-</span> eval y
                    safediv n m</code></pre></div>
<p><strong>Q:</strong> Show that the version of eval defined using <code>(&gt;&gt;=)</code> is equivalent to our original version, by expanding the definition of <code>(&gt;&gt;=)</code>.</p>
<h2 id="monad-is-a-typeclass">Monad is a typeclass</h2>
<p>The <code>do</code> notation for effects is not specific to the <code>Maybe</code> or <code>IO</code> type, but can be used with any applicative type that forms a monad. In Haskell, the concept of a monad is captured by the following built-in declaration:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span> 
<span class="ot"> (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b

<span class="ot"> return ::</span> a <span class="ot">-&gt;</span> m a
 return <span class="fu">=</span> pure</code></pre></div>
<p>That is, a monad is an applicative type <code>m</code> that supports <code>return</code> and <code>(&gt;&gt;=)</code> functions of the specified types. The default definition <code>return = pure</code> means that return is normally just another name for the applicative function <code>pure</code>, but can be overridden in instances declarations if desired.</p>
<p>The function return is included in the Monad class for historical reasons, and to ensure backwards compatibility with existing code, articles and textbooks that assume the class declaration includes both <code>return</code> and <code>(&gt;&gt;=)</code> functions.</p>
<h2 id="the-maybe-monad">The <code>Maybe</code> monad</h2>
<p>It is now straightforward to make Maybe into a monadic type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
   <span class="co">-- return      :: a -&gt; Maybe a</span>
   return x       <span class="fu">=</span>  <span class="dt">Just</span> x

   <span class="co">-- (&gt;&gt;=)       :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b</span>
   <span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span>  <span class="dt">Nothing</span>
   (<span class="dt">Just</span> x) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span>  f x</code></pre></div>
<p>It is because of this declaration that the do notation can be used to sequence <code>Maybe</code> values. In the next few sections we give some further examples of types that are monadic, and the benefits that result from recognising and exploiting this fact.</p>
<h2 id="the-list-monad">The List Monad</h2>
<p>As with applicatives, maybe represents exceptions and lists non-determinism. We saw how the (monadic) do notation propagates exceptions on maybe values.</p>
<p><strong>Q:</strong> Lets define the instance monad for lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span> 
 <span class="co">-- (&gt;&gt;=)  :: [a] -&gt; (a -&gt; [b]) -&gt; [b]</span>
 xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> concatMap f xs

 <span class="co">-- return :: a -&gt; [a]</span>
 return x <span class="fu">=</span> [x]</code></pre></div>
<p>(Aside: in this context, <code>[]</code> denotes the list type <code>[a]</code> without its parameter.) That is, <code>return</code> simply converts a value into one result containing that value, while <code>(&gt;&gt;=)</code> provides a means of combining computations that may produce multiple results: <code>xs &gt;&gt;= f</code> applies the function <code>f</code> to each of the results in the list xs to give a nested list of results, which is then concatenated to give a single list of results.</p>
<p>As a simple example of the use of the list monad, a function that returns all possible ways of pairing elements from two lists can be defined using the do notation as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- pairs :: [a] -&gt; [b] -&gt; [(a,b)]</span>
<span class="ot">&gt;</span> pairs xs ys <span class="fu">=</span>  <span class="kw">do</span> x <span class="ot">&lt;-</span> xs
<span class="ot">&gt;</span>                   y <span class="ot">&lt;-</span> ys
<span class="ot">&gt;</span>                   return (x, y)</code></pre></div>
<p><strong>Q:</strong> What is the value of</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pairs [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="st">&quot;cat&quot;</span></code></pre></div>
<p><strong>Q:</strong> What is the value of</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pairs [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="st">&quot;cat&quot;</span>]</code></pre></div>
<p><strong>Q:</strong> Write pairs using the bind operator.</p>
<p>That is, consider each possible value x from the list xs, and each value y from the list ys, and return the pair (x,y). It is interesting to note the similarity to how this function would be defined using the list comprehension notation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pairs xs ys <span class="fu">=</span> [(x, y) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs, y <span class="ot">&lt;-</span> ys]</code></pre></div>
<p>or in Python syntax:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">def pairs(xs, ys)<span class="fu">:</span> return [(x,y) for x <span class="kw">in</span> xs for y <span class="kw">in</span> ys]</code></pre></div>
<p>In fact, there is a formal connection between the do notation and the comprehension notation. Both are simply different shorthands for repeated use of the <code>(&gt;&gt;=)</code> operator for lists. Indeed, the language Gofer that was one of the precursors to Haskell permitted the comprehension notation to be used with any monad. For simplicity however, Haskell only allows the comprehension notation to be used with lists.</p>
<p><strong>Q:</strong> Can you write the applicativ <code>andTable</code> using do nation?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">andTable <span class="fu">=</span> (pure (<span class="fu">&amp;&amp;</span>)) <span class="fu">&lt;*&gt;</span> [<span class="dt">True</span>,<span class="dt">False</span>] <span class="fu">&lt;*&gt;</span> [<span class="dt">True</span>, <span class="dt">False</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> andTable <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   x <span class="ot">&lt;-</span> [<span class="dt">True</span>, <span class="dt">False</span>]
<span class="ot">&gt;</span>   y <span class="ot">&lt;-</span> [<span class="dt">True</span>, <span class="dt">False</span>]
<span class="ot">&gt;</span>   return (x <span class="fu">&amp;&amp;</span> y)</code></pre></div>
<p>Lets see how this computes!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">andTable

 <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> [<span class="dt">True</span>, <span class="dt">False</span>]
      y <span class="ot">&lt;-</span> [<span class="dt">True</span>, <span class="dt">False</span>]
      return (x <span class="fu">&amp;&amp;</span> y)

 <span class="co">-- bind notation</span>
 <span class="fu">=</span> ([<span class="dt">True</span>, <span class="dt">False</span>] <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> 
   ([<span class="dt">True</span>, <span class="dt">False</span>] <span class="fu">&gt;&gt;=</span> (\y <span class="ot">-&gt;</span> 
     return (x <span class="fu">&amp;&amp;</span> y)
   )))

 <span class="co">-- concatMap on x </span>
 <span class="fu">=</span>  (\x <span class="ot">-&gt;</span> 
     ([<span class="dt">True</span>, <span class="dt">False</span>] <span class="fu">&gt;&gt;=</span> (\y <span class="ot">-&gt;</span> 
       return (x <span class="fu">&amp;&amp;</span> y)
    ))) <span class="dt">True</span>
 <span class="fu">++</span> (\x <span class="ot">-&gt;</span> 
   ([<span class="dt">True</span>, <span class="dt">False</span>] <span class="fu">&gt;&gt;=</span> (\y <span class="ot">-&gt;</span> 
     return (x <span class="fu">&amp;&amp;</span> y)
   ))) <span class="dt">False</span>

 <span class="co">-- apply</span>
 <span class="fu">=</span>  [<span class="dt">True</span>, <span class="dt">False</span>] <span class="fu">&gt;&gt;=</span> (\y <span class="ot">-&gt;</span> 
       return (<span class="dt">True</span> <span class="fu">&amp;&amp;</span> y)
    )
 <span class="fu">++</span> [<span class="dt">True</span>, <span class="dt">False</span>] <span class="fu">&gt;&gt;=</span> (\y <span class="ot">-&gt;</span> 
     return (<span class="dt">False</span> <span class="fu">&amp;&amp;</span> y)
   )

 <span class="co">-- concatMap on y</span>
 <span class="fu">=</span>  (\y <span class="ot">-&gt;</span> 
       return (<span class="dt">True</span> <span class="fu">&amp;&amp;</span> y)
    ) <span class="dt">True</span> 
 <span class="fu">++</span> (\y <span class="ot">-&gt;</span> 
       return (<span class="dt">True</span> <span class="fu">&amp;&amp;</span> y)
    ) <span class="dt">False</span> 
 <span class="fu">++</span> (\y <span class="ot">-&gt;</span> 
     return (<span class="dt">False</span> <span class="fu">&amp;&amp;</span> y)
   ) <span class="dt">True</span> 
 <span class="fu">++</span> (\y <span class="ot">-&gt;</span> 
     return (<span class="dt">False</span> <span class="fu">&amp;&amp;</span> y)
   ) <span class="dt">False</span> 

 <span class="co">-- apply</span>
 <span class="fu">=</span>  return (<span class="dt">True</span>  <span class="fu">&amp;&amp;</span> <span class="dt">True</span>)
 <span class="fu">++</span> return (<span class="dt">True</span>  <span class="fu">&amp;&amp;</span> <span class="dt">False</span>)
 <span class="fu">++</span> return (<span class="dt">False</span> <span class="fu">&amp;&amp;</span> <span class="dt">True</span>)
 <span class="fu">++</span> return (<span class="dt">False</span> <span class="fu">&amp;&amp;</span> <span class="dt">False</span>)

 <span class="co">-- booleans</span>
 <span class="fu">=</span>  return <span class="dt">True</span>
 <span class="fu">++</span> return <span class="dt">False</span>
 <span class="fu">++</span> return <span class="dt">False</span>
 <span class="fu">++</span> return <span class="dt">False</span>

 <span class="co">-- return x = [x]</span>
 <span class="fu">=</span>  [<span class="dt">True</span>]
 <span class="fu">++</span> [<span class="dt">False</span>]
 <span class="fu">++</span> [<span class="dt">False</span>]
 <span class="fu">++</span> [<span class="dt">False</span>]

 <span class="co">-- appending</span>
 <span class="fu">=</span>  [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">False</span>, <span class="dt">False</span>]</code></pre></div>
<h2 id="imperative-functional-programming">Imperative Functional Programming</h2>
<p>Consider the following problem. I have a (finite) list of values, e.g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">vals0 ::</span> [<span class="dt">Char</span>]
vals0 <span class="fu">=</span> [<span class="ch">'d'</span>, <span class="ch">'b'</span>, <span class="ch">'d'</span>, <span class="ch">'d'</span>, <span class="ch">'a'</span>]</code></pre></div>
<p>that I want to canonize into a list of integers, where each distinct value gets the next highest number. So I want to see something like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> canonize vals0
[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>]</code></pre></div>
<p>similarly, I want:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> canonize [<span class="st">&quot;zebra&quot;</span>, <span class="st">&quot;mouse&quot;</span>, <span class="st">&quot;zebra&quot;</span>, <span class="st">&quot;zebra&quot;</span>, <span class="st">&quot;owl&quot;</span>]
[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>]</code></pre></div>
<p><strong>Q:</strong> How would you write <code>canonize</code> in Python?</p>
<p><strong>Q:</strong> How would you write canonize in Haskell?</p>
<p>Not very clean! Next let’s see how you can get the stateful benefits on imperative programming in Haskell using a state monad and how <code>IO</code> is just a special case of the state monad.</p>
<h2 id="the-state-monad">The State Monad</h2>
<p>Now let us consider the problem of writing functions that manipulate some kind of state, represented by a type whose internal details are not important for the moment:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p>The most basic form of function on this type is a state transformer (abbreviated by <code>ST</code>), which takes the current state as its argument, and produces a modified state as its result, in which the modified state reflects any side effects performed by the function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ST</span> <span class="fu">=</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">State</span></code></pre></div>
<p>In general, however, we may wish to return a result value in addition to updating the state. For example, a function for incrementing a counter may wish to return the current value of the counter. For this reason, we generalise our type of state transformers to also return a result value, with the type of such values being a parameter of the <code>ST</code> type:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">ST</span> a <span class="fu">=</span> <span class="dt">State</span> <span class="ot">-&gt;</span> (a, <span class="dt">State</span>)</code></pre></div>
<p>Such functions can be depicted as follows, where <code>s</code> is the input state, <code>s'</code> is the output state, and <code>v</code> is the result value:</p>
<div class="figure">
<img src="http://ucsd-pl.github.io/cse230/static/monad1.png" title="State 1" alt="alt text" />
<p class="caption">alt text</p>
</div>
<p>The state transformer may also wish to take argument values. However, there is no need to further generalise the <code>ST</code> type to take account of this, because this behaviour can already be achieved by exploiting currying. For example, a state transformer that takes a character and returns an integer would have type <code>Char -&gt; ST Int</code>, which abbreviates the curried function type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">State</span>)</code></pre></div>
<p>depicted by:</p>
<div class="figure">
<img src="http://ucsd-pl.github.io/cse230/static/monad2.png" title="State 2" alt="alt text" />
<p class="caption">alt text</p>
</div>
<p>Returning to the subject of monads, it is now straightforward to make <code>ST</code> into an instance of a monadic type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">ST</span> <span class="kw">where</span>
   <span class="co">-- return :: a -&gt; ST a</span>
   return x  <span class="fu">=</span>  \s <span class="ot">-&gt;</span> (x,s)

   <span class="co">-- (&gt;&gt;=)  :: ST a -&gt; (a -&gt; ST b) -&gt; ST b</span>
   st <span class="fu">&gt;&gt;=</span> f  <span class="fu">=</span>  \s <span class="ot">-&gt;</span> <span class="kw">let</span> (x,s') <span class="fu">=</span> st s <span class="kw">in</span> f x s'</code></pre></div>
<p>That is, return converts a value into a state transformer that simply returns that value without modifying the state:</p>
<div class="figure">
<img src="http://ucsd-pl.github.io/cse230/static/monad3.png" title="State 3" alt="alt text" />
<p class="caption">alt text</p>
</div>
<p>In turn, <code>(&gt;&gt;=)</code> provides a means of sequencing state transformers: <code>st &gt;&gt;= f</code> applies the state transformer <code>st</code> to an initial state <code>s</code>, then applies the function <code>f</code> to the resulting value <code>x</code> to give a second state transformer <code>(f x)</code>, which is then applied to the modified state <code>s</code>’ to give the final result:</p>
<div class="figure">
<img src="http://ucsd-pl.github.io/cse230/static/monad4.png" title="State 4" alt="alt text" />
<p class="caption">alt text</p>
</div>
<p>Note that <code>return</code> could also be defined by <code>return x s = (x,s)</code>. However, we prefer the above definition in which the second argument <code>s</code> is shunted to the body of the definition using a lambda abstraction, because it makes explicit that <code>return</code> is a function that takes a single argument and returns a state transformer, as expressed by the type <code>a -&gt; ST a</code>: A similar comment applies to the above definition for <code>(&gt;&gt;=)</code>.</p>
<p>We conclude this section with a technical aside. In Haskell, types defined using the type mechanism cannot be made into instances of classes. Hence, in order to make ST into an instance of the class of monadic types, in reality it needs to be redefined using the data mechanism, which requires introducing a dummy constructor (called S for brevity):</p>
<p><em>Technicallity:</em> In Haskell, types defined using the type mechanism cannot be made into instances of classes. Hence, in order to make <code>ST</code> into an instance of the class of monadic types, in reality it needs to be redefined using the data or newtype mechanism, which requires introducing a dummy constructor (called S for brevity):</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">ST0</span> a <span class="fu">=</span> <span class="dt">S0</span> (<span class="dt">State</span> <span class="ot">-&gt;</span> (a, <span class="dt">State</span>))
<span class="ot">&gt;</span>              <span class="kw">deriving</span> (<span class="dt">Functor</span>)</code></pre></div>
<p>It is convenient to define our own application function for this type, which simply removes the dummy constructor:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; apply0 ::</span> <span class="dt">ST0</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> (a, <span class="dt">State</span>)
<span class="ot">&gt;</span> apply0 (<span class="dt">S0</span> f) s0 <span class="fu">=</span> f s0</code></pre></div>
<p>In turn, <code>ST0</code> is now defined as a monadic type as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">ST0</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="co">-- pure :: a -&gt; ST0 a</span>
<span class="ot">&gt;</span>   pure x   <span class="fu">=</span> <span class="dt">S0</span> (\s <span class="ot">-&gt;</span> (x, s))
<span class="ot">&gt;</span>   <span class="co">-- (&lt;*&gt;) :: ST0 (a -&gt; b) -&gt; ST0 a -&gt; ST0 b</span>
<span class="ot">&gt;</span>   f <span class="fu">&lt;*&gt;</span> x  <span class="fu">=</span> <span class="dt">S0</span> (\s <span class="ot">-&gt;</span> <span class="kw">let</span> (f',s')  <span class="fu">=</span> apply0 f s  <span class="kw">in</span> 
<span class="ot">&gt;</span>                        <span class="kw">let</span> (x',s'') <span class="fu">=</span> apply0 x s' <span class="kw">in</span> 
<span class="ot">&gt;</span>                          (f' x',s'')) 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">ST0</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="co">-- (&gt;&gt;=)  :: ST0 a -&gt; (a -&gt; ST0 b) -&gt; ST0 b</span>
<span class="ot">&gt;</span>   st <span class="fu">&gt;&gt;=</span> f   <span class="fu">=</span> <span class="dt">S0</span> ( \s <span class="ot">-&gt;</span> <span class="kw">let</span> (x, s') <span class="fu">=</span> apply0 st s <span class="kw">in</span>
<span class="ot">&gt;</span>                           apply0 (f x) s'
<span class="ot">&gt;</span>                   )</code></pre></div>
<h2 id="a-simple-example">A simple example</h2>
<p>Intuitively, a value of type <code>ST a</code> (or <code>ST0 a</code>) is simply an action that returns an a value. The sequencing combinators allow us to combine simple actions to get bigger actions, and the <code>apply0</code> allows us to execute an action from some initial state.</p>
<p><strong>Q:</strong> To get warmed up with the state-transformer monad, lets write a simple sequencing combinator</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</code></pre></div>
<p>which, in a nutshell, <code>a1 &gt;&gt; a2</code> takes the actions <code>a1</code> and <code>a2</code> and returns the mega action which is <code>a1-then-a2-returning-the-value-returned-by-a2</code>.</p>
<p>Next, lets see how to implement a “global counter” in Haskell, by using a state transformer, in which the internal state is simply the next integer</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></code></pre></div>
<p>In order to generate the next integer, we define a special state transformer that simply returns the current state as its result, and the next integer as the new state:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span> 
<span class="kw">data</span> <span class="dt">ST0</span> a <span class="fu">=</span> <span class="dt">S0</span> (<span class="dt">State</span> <span class="ot">-&gt;</span> (a, <span class="dt">State</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fresh ::</span> <span class="dt">ST0</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> fresh <span class="fu">=</span> <span class="dt">S0</span> f 
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
<span class="ot">&gt;</span>     f x <span class="fu">=</span> (x, x<span class="fu">+</span><span class="dv">1</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; freshName ::</span> <span class="dt">ST0</span> <span class="dt">String</span>
<span class="ot">&gt;</span> freshName <span class="fu">=</span> <span class="dt">S0</span> f
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">Int</span>)
<span class="ot">&gt;</span>     f x <span class="fu">=</span> (<span class="st">&quot;Name: &quot;</span> <span class="fu">++</span> show x, x<span class="fu">+</span><span class="dv">1</span>)</code></pre></div>
<p>Note that fresh is a state transformer (where the state is itself just <code>Int</code>), that is an action that happens to return integer values.</p>
<p><strong>Q:</strong> What does the following evaluate to?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> apply0 fresh <span class="dv">0</span></code></pre></div>
<p><strong>Q:</strong> Consider the function <code>surprise</code> defined as:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> surprise1 <span class="fu">=</span> 
<span class="ot">&gt;</span>   fresh <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>   fresh <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>   fresh <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>   freshName</code></pre></div>
<p>Indeed, we are just chaining together four fresh actions to get a single action that “bumps up” the counter by 4. That is, the following versions of <code>surprise</code> are also equivalent:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> surprise1' <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   fresh
<span class="ot">&gt;</span>   fresh
<span class="ot">&gt;</span>   fresh
<span class="ot">&gt;</span>   fresh
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> surprise1'' <span class="fu">=</span> 
<span class="ot">&gt;</span>   fresh <span class="fu">&gt;&gt;</span> fresh <span class="fu">&gt;&gt;</span> fresh <span class="fu">&gt;&gt;</span> fresh</code></pre></div>
<p>Now, the <code>(&gt;&gt;=)</code> sequencer is kind of like <code>(&gt;&gt;)</code> only it allows you to “remember” intermediate values that may have been returned. Similarly,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ST0</span> a</code></pre></div>
<p>takes a value <code>x</code> and yields an action that doesnt actually transform the state, but just returns the same value <code>x</code>. So, putting things together, how do you think this behaves?</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> surprise2 <span class="fu">=</span> 
<span class="ot">&gt;</span>   fresh <span class="fu">&gt;&gt;=</span> \n1 <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>   freshName <span class="fu">&gt;&gt;=</span> \n2 <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>   fresh <span class="fu">&gt;&gt;</span>
<span class="ot">&gt;</span>   fresh <span class="fu">&gt;&gt;</span>
<span class="ot">&gt;</span>   return (n1, n2)</code></pre></div>
<p><strong>Q:</strong> What does the following evaluate to?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> apply0 surprise2 <span class="dv">0</span></code></pre></div>
<p>Of course, the do business is just nice syntax for the above:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> surprise2' <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   fresh 
<span class="ot">&gt;</span>   n1 <span class="ot">&lt;-</span> fresh
<span class="ot">&gt;</span>   n2 <span class="ot">&lt;-</span> fresh
<span class="ot">&gt;</span>   fresh
<span class="ot">&gt;</span>   fresh
<span class="ot">&gt;</span>   return (n1, n2)</code></pre></div>
<p>is just like <code>surprise2</code>.</p>
<h2 id="a-more-interesting-example">A more interesting example</h2>
<p>By way of an example of using the state monad, let us define a type of binary trees whose leaves contains values of some type <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a
<span class="ot">&gt;</span>             <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)
<span class="ot">&gt;</span>             <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Here is a simple example:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tree ::</span> <span class="dt">Tree</span> <span class="dt">Char</span>
<span class="ot">&gt;</span> tree <span class="fu">=</span>  <span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="ch">'a'</span>) (<span class="dt">Leaf</span> <span class="ch">'b'</span>)) (<span class="dt">Leaf</span> <span class="ch">'c'</span>)</code></pre></div>
<p>Now consider the problem of defining a function that labels each leaf in such a tree with a unique or “fresh” integer, for example, returning the following:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> tree' <span class="fu">=</span>  <span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span> (<span class="ch">'a'</span>, <span class="dv">0</span>)) (<span class="dt">Leaf</span> (<span class="ch">'b'</span>, <span class="dv">1</span>))) (<span class="dt">Leaf</span> (<span class="ch">'c'</span>, <span class="dv">2</span>))</code></pre></div>
<p>This can be achieved by taking the next fresh integer as an additional argument to the function, and returning the next fresh integer as an additional result, for instance, as shown below:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a
            <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mlabel ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">ST0</span> (<span class="dt">Tree</span> (a,<span class="dt">Int</span>))
<span class="ot">&gt;</span> mlabel (<span class="dt">Leaf</span> v)   <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   n <span class="ot">&lt;-</span> fresh 
<span class="ot">&gt;</span>   return (<span class="dt">Leaf</span> (v, n))
<span class="ot">&gt;</span> mlabel (<span class="dt">Node</span> l r) <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   l' <span class="ot">&lt;-</span> mlabel l  <span class="co">-- ::ST0 (Tree (a, Int))</span>
<span class="ot">&gt;</span>   r' <span class="ot">&lt;-</span> mlabel r  
<span class="ot">&gt;</span>   return (<span class="dt">Node</span> l' r')</code></pre></div>
<p>Note that the programmer does not have to worry about the tedious and error-prone task of dealing with the plumbing of fresh labels, as this is handled automatically by the state monad.</p>
<p>Finally, we can now define a function that labels a tree by simply applying the resulting state transformer with zero as the initial state, and then discarding the final state:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; label  ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (a, <span class="dt">Int</span>)
<span class="ot">&gt;</span> label t <span class="fu">=</span> fst (apply0 (mlabel t) <span class="dv">0</span>)</code></pre></div>
<p>For example, <code>label tree</code> gives the following result:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> label tree
<span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span> (<span class="ch">'a'</span>, <span class="dv">0</span>)) (<span class="dt">Leaf</span> (<span class="ch">'b'</span>,<span class="dv">1</span>))) (<span class="dt">Leaf</span> (<span class="ch">'c'</span>, <span class="dv">2</span>))</code></pre></div>
<p><strong>Q:</strong> Define a function <code>app :: (State -&gt; State) -&gt; ST0 State</code>, such that fresh can be redefined by <code>fresh = app (+1)</code>.</p>
<p><strong>Q:</strong> Define a function <code>run :: ST0 a -&gt; State -&gt; a</code>, such that label can be redefined by <code>label t = run (mlabel t) 0</code>.</p>
<h2 id="the-generic-state-transformer">The Generic State Transformer</h2>
<p>Let us use our generic state monad to rewrite the tree labeling function from above. The generic monad is defined in the <a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#t:State"><code>Control.Monad.State.Lazy</code></a> and, mush like our definition takes two arguments: one for state and one for the result</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ST.State</span> s a </code></pre></div>
<p>Note that the actual type definition of the generic transformer is hidden from us, so we must use only the publicly exported functions: <code>get</code>, <code>put</code> and <code>runState</code> (in addition to the monadic functions we get for free.)</p>
<p>Recall the action that returns the next fresh integer. Using the generic state-transformer, we write it as:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; freshS ::</span> <span class="dt">ST.State</span> <span class="dt">Int</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> freshS <span class="fu">=</span> <span class="kw">do</span> n <span class="ot">&lt;-</span> get
<span class="ot">&gt;</span>             put (n<span class="fu">+</span><span class="dv">1</span>)
<span class="ot">&gt;</span>             return n</code></pre></div>
<p>Now, the labeling function is straightforward</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mlabelS ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">ST.State</span> <span class="dt">Int</span> (<span class="dt">Tree</span> (a,<span class="dt">Int</span>))
<span class="ot">&gt;</span> mlabelS (<span class="dt">Leaf</span> x)   <span class="fu">=</span>  <span class="kw">do</span> n <span class="ot">&lt;-</span> freshS
<span class="ot">&gt;</span>                          return (<span class="dt">Leaf</span> (x, n))
<span class="ot">&gt;</span> mlabelS (<span class="dt">Node</span> l r) <span class="fu">=</span>  <span class="kw">do</span> l' <span class="ot">&lt;-</span> mlabelS l
<span class="ot">&gt;</span>                          r' <span class="ot">&lt;-</span> mlabelS r
<span class="ot">&gt;</span>                          return (<span class="dt">Node</span> l' r')</code></pre></div>
<p>Easy enough!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> runState (mlabelS tree) <span class="dv">0</span>
(<span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span> (<span class="ch">'a'</span>, <span class="dv">0</span>)) (<span class="dt">Leaf</span> (<span class="ch">'b'</span>, <span class="dv">1</span>))) (<span class="dt">Leaf</span> (<span class="ch">'c'</span>, <span class="dv">2</span>)), <span class="dv">3</span>)</code></pre></div>
<p>We can execute the action from any initial state of our choice</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> runState (mlabelS tree) <span class="dv">1000</span>
(<span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span> (<span class="ch">'a'</span>,<span class="dv">1000</span>)) (<span class="dt">Leaf</span> (<span class="ch">'b'</span>,<span class="dv">1001</span>))) (<span class="dt">Leaf</span> (<span class="ch">'c'</span>,<span class="dv">1002</span>)),<span class="dv">1003</span>)</code></pre></div>
<p>Now, whats the point of a generic state transformer if we can’t have richer states.</p>
<p>Let’s now count the frequency of each leaf value appears in the tree.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> tree2 <span class="fu">=</span>  <span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="ch">'a'</span>) (<span class="dt">Leaf</span> <span class="ch">'b'</span>))
<span class="ot">&gt;</span>               (<span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="ch">'a'</span>) (<span class="dt">Leaf</span> <span class="ch">'c'</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">let</span> tree2       <span class="fu">=</span> <span class="dt">Node</span> tree tree
ghci<span class="fu">&gt;</span> <span class="kw">let</span> (tree2', s) <span class="fu">=</span> runState (mlabelM tree) <span class="fu">$</span> <span class="dt">M</span> <span class="dv">0</span> empty

ghci<span class="fu">&gt;</span> tree2'
<span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span> (<span class="ch">'a'</span>, <span class="dv">0</span>)) (<span class="dt">Leaf</span> (<span class="ch">'b'</span>, <span class="dv">1</span>)))
     (<span class="dt">Node</span> (<span class="dt">Leaf</span> (<span class="ch">'a'</span>, <span class="dv">2</span>)) (<span class="dt">Leaf</span> (<span class="ch">'c'</span>, <span class="dv">3</span>)))

ghci<span class="fu">&gt;</span> s
<span class="dt">M</span> {index <span class="fu">=</span> <span class="dv">4</span>, freq <span class="fu">=</span> fromList [(<span class="ch">'a'</span>,<span class="dv">2</span>),(<span class="ch">'b'</span>,<span class="dv">1</span>),(<span class="ch">'c'</span>,<span class="dv">1</span>)]}</code></pre></div>
<p>Define your state so that it has now two elements:</p>
<ul>
<li>each node gets a new label (as before),</li>
<li>the state also contains a map of the frequency with which each leaf value appears in the tree.</li>
</ul>
<p>Thus, our state will now have two elements, an integer denoting the next <em>fresh</em> integer, and a <code>Map a Int</code> denoting the number of times each leaf value appears in the tree.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">MyState</span> k <span class="fu">=</span> <span class="dt">M</span> {<span class="ot"> index ::</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span>                    ,<span class="ot"> count ::</span> [(k, <span class="dt">Int</span>)]}
<span class="ot">&gt;</span>                  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We write an action that returns the next fresh integer as</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; freshM ::</span> <span class="dt">ST.State</span> (<span class="dt">MyState</span> k) <span class="dt">Int</span>  
<span class="ot">&gt;</span> freshM <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>    s     <span class="ot">&lt;-</span> get
<span class="ot">&gt;</span>    <span class="kw">let</span> n  <span class="fu">=</span> index s
<span class="ot">&gt;</span>    put <span class="fu">$</span> s { index <span class="fu">=</span> n <span class="fu">+</span> <span class="dv">1</span> }
<span class="ot">&gt;</span>    return n</code></pre></div>
<p>Similarly, we want an action that updates the frequency of a given element <code>k</code></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; updFreqM ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">ST.State</span> (<span class="dt">MyState</span> k) ()  
<span class="ot">&gt;</span> updFreqM k <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   <span class="dt">M</span> i c <span class="ot">&lt;-</span> get <span class="co">--  c :: [(k, Int)]</span>
<span class="ot">&gt;</span>   <span class="kw">case</span> lookup k c <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">Just</span> ki <span class="ot">-&gt;</span> put (<span class="dt">M</span> i ((k, ki<span class="fu">+</span><span class="dv">1</span>)<span class="fu">:</span>c))
<span class="ot">&gt;</span>     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> put (<span class="dt">M</span> i ((k,<span class="dv">1</span>)<span class="fu">:</span>c)) </code></pre></div>
<p>And with these two, we are done</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mlabelM ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Tree</span> k 
<span class="ot">&gt;</span>   <span class="ot">-&gt;</span> <span class="dt">ST.State</span> (<span class="dt">MyState</span> k) (<span class="dt">Tree</span> (k, <span class="dt">Int</span>))  
<span class="ot">&gt;</span> mlabelM (<span class="dt">Leaf</span> v) <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   n <span class="ot">&lt;-</span> freshM
<span class="ot">&gt;</span>   updFreqM v 
<span class="ot">&gt;</span>   return (<span class="dt">Leaf</span> (v,n))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> mlabelM (<span class="dt">Node</span> l r) <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   l' <span class="ot">&lt;-</span> mlabelM l 
<span class="ot">&gt;</span>   r' <span class="ot">&lt;-</span> mlabelM r 
<span class="ot">&gt;</span>   return (<span class="dt">Node</span> l' r')</code></pre></div>
<p>Now, our initial state will be something like</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> initM <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span></code></pre></div>
<p>In short, <code>State</code> makes global variables (or “statefull” programming) really easy.</p>
<h2 id="the-io-monad">The IO Monad</h2>
<p>Recall that interactive programs in Haskell are written using the type <code>IO a</code> of “actions” that return a result of type <code>a</code>, but may also perform some input/output.</p>
<p>Sounds familiar?</p>
<p>A number of primitives are provided for building values of this type, including:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return<span class="ot">  ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">(&gt;&gt;=)   ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b
getChar<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">Char</span>
putChar<span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>The use of <code>return</code> and <code>(&gt;&gt;=)</code> means that <code>IO</code> is monadic, and hence that the <code>do</code> notation can be used to write interactive programs. For example, the action that reads a string of characters from the keyboard can be defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">getLine<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span>
getLine <span class="fu">=</span>  <span class="kw">do</span> x <span class="ot">&lt;-</span> getChar
              <span class="kw">if</span> x <span class="fu">==</span> <span class="ch">'\n'</span> <span class="kw">then</span>
                 return []
              <span class="kw">else</span>
                 <span class="kw">do</span> xs <span class="ot">&lt;-</span> getLine
                    return (x<span class="fu">:</span>xs)</code></pre></div>
<p>It is interesting to note that the <code>IO</code> monad can be viewed as a special case of the <strong>state monad</strong>, in which the internal state is a suitable representation of the “state of the world”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">   <span class="kw">type</span> <span class="dt">World</span> <span class="fu">=</span> <span class="fu">...</span>

   <span class="kw">type</span> <span class="dt">IO</span> a  <span class="fu">=</span> <span class="dt">World</span> <span class="ot">-&gt;</span> (a, <span class="dt">World</span>)</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">   <span class="kw">type</span> <span class="dt">IO</span> a  <span class="fu">=</span> <span class="dt">ST.State</span> <span class="dt">World</span> a</code></pre></div>
<p>That is, an action can be viewed as a function that takes the current state of the world as its argument, and produces a value and a modified world as its result, in which the modified world reflects any input/output performed by the action. In reality, Haskell’s compiler GHC implement actions in a more efficient manner, but for the purposes of understanding the behaviour of actions, the above interpretation can be useful.</p>
<h2 id="derived-primitives">Derived Primitives</h2>
<p>An important benefit of abstracting out the notion of a monad into a single typeclass, is that it then becomes possible to define a number of useful functions that work in an arbitrary monad.</p>
<p>We’ve already seen this in the pairs function</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"> pairs xs ys <span class="fu">=</span> <span class="kw">do</span>
   x <span class="ot">&lt;-</span> xs
   y <span class="ot">&lt;-</span> ys
   return (x, y)</code></pre></div>
<p>What do you think the type of the above is ? (I left out an annotation deliberately!)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t pairs
pairs<span class="fu">:</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m (a, b)</code></pre></div>
<p>It takes two monadic values and returns a single paired monadic value. Be careful though! The function above will behave differently depending on what specific monad instance it is used with! If you use the <code>Maybe</code> monad</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> pairs (<span class="dt">Nothing</span>) (<span class="dt">Just</span> <span class="ch">'a'</span>)
<span class="dt">Nothing</span>

ghci<span class="fu">&gt;</span> pairs (<span class="dt">Just</span> <span class="dv">42</span>) (<span class="dt">Nothing</span>)
<span class="dt">Just</span> <span class="dv">42</span>

ghci<span class="fu">&gt;</span> pairs (<span class="dt">Just</span> <span class="dv">2</span>) (<span class="dt">Just</span> <span class="ch">'a'</span>)
<span class="dt">Just</span> (<span class="dv">2</span>, a)</code></pre></div>
<p>this generalizes to the list monad</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> pairs [] [<span class="ch">'a'</span>]
[]

ghci<span class="fu">&gt;</span> pairs [<span class="dv">42</span>] []
[]

ghci<span class="fu">&gt;</span> pairs [<span class="dv">2</span>] [<span class="ch">'a'</span>]
[(<span class="dv">2</span>, a)]

ghci<span class="fu">&gt;</span> pairs [<span class="dv">1</span>,<span class="dv">2</span>] <span class="st">&quot;ab&quot;</span>
[(<span class="dv">1</span>,<span class="ch">'a'</span>) , (<span class="dv">2</span>, <span class="ch">'a'</span>), (<span class="dv">1</span>, <span class="ch">'b'</span>), (<span class="dv">2</span>, <span class="ch">'b'</span>)]</code></pre></div>
<p>However, the behavior is quite different with the <code>IO</code> monad</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> pairs getChar getChar
<span class="dv">40</span>(<span class="ch">'4'</span>,<span class="ch">'0'</span>)</code></pre></div>
<p><strong>Q:</strong> What is the type of <code>foo</code> defined as:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; foo ::</span> <span class="dt">Monad</span> a <span class="ot">=&gt;</span> (x <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> a x <span class="ot">-&gt;</span> a y
<span class="ot">&gt;</span> <span class="co">-- foo :: (x -&gt; y) -&gt; [x] -&gt; [y] -- map </span>
<span class="ot">&gt;</span> <span class="co">-- foo :: (x -&gt; y) -&gt;  Maybe x -&gt; Maybe y -- map </span>
<span class="ot">&gt;</span> foo f z <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> z
<span class="ot">&gt;</span>              return (f x)</code></pre></div>
<p>Whoa! This is actually very useful, because in one-shot we’ve defined a map function for every monad type!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> foo (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]
[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]

ghci<span class="fu">&gt;</span> foo (<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">10</span>)
<span class="dt">Just</span> <span class="dv">11</span>

ghci<span class="fu">&gt;</span> foo (<span class="fu">+</span><span class="dv">1</span>) <span class="dt">Nothing</span>
<span class="dt">Nothing</span></code></pre></div>
<p>Thus, every <code>Monad</code> also is a <code>Functor</code>! Which we already know, because of transitivity!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> m)     <span class="ot">=&gt;</span> <span class="dt">Applicative</span> m <span class="kw">where</span>
<span class="kw">instance</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></code></pre></div>
<p><strong>Q:</strong> Consider the function <code>baz</code> defined as:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> baz mmx <span class="fu">=</span> <span class="kw">do</span> mx <span class="ot">&lt;-</span> mmx
<span class="ot">&gt;</span>              x  <span class="ot">&lt;-</span> mx
<span class="ot">&gt;</span>              return (x<span class="fu">+</span><span class="dv">1</span>)</code></pre></div>
<p>mmx &gt;&gt;= (-&gt; return mx)</p>
<p>mmx <code>concatMap</code> return</p>
<p>concatMap return mmx concatMap return []</p>
<p>What does <code>baz [[1, 2], [3, 4]]</code> return?</p>
<ol style="list-style-type: decimal">
<li><code>[1, 3], [1, 4], [2, 3], [2, 4]]</code></li>
<li><code>[1, 2, 3, 4]</code></li>
<li><code>[[1, 3], [2, 4]]</code></li>
<li><code>[]</code></li>
<li><code>Type error</code></li>
</ol>
<p>This above notion of concatenation generalizes to any monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">join    ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a
join mmx <span class="fu">=</span> <span class="kw">do</span> mx <span class="ot">&lt;-</span> mmx
              x  <span class="ot">&lt;-</span> mx
              return x</code></pre></div>
<p>As a final example, another usefull function is <code>mapM</code> which maps a list of arguments to a monadic action, collecting their results:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mapM<span class="ot">          ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [b]
mapM _ []     <span class="fu">=</span>  return []
mapM f (x<span class="fu">:</span>xs) <span class="fu">=</span>  <span class="kw">do</span> y  <span class="ot">&lt;-</span> f x
                    ys <span class="ot">&lt;-</span> mapM f xs
                    return (y<span class="fu">:</span>ys)</code></pre></div>
<h2 id="monads-as-programmable-semicolon">Monads as Programmable Semicolon</h2>
<p>It is sometimes useful to sequence two monadic expressions, but discard the result value produced by the first:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;)     ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
mx <span class="fu">&gt;&gt;</span> my <span class="fu">=</span>  <span class="kw">do</span> {_ <span class="ot">&lt;-</span> mx; 
                y <span class="ot">&lt;-</span> my; 
               return y}</code></pre></div>
<p>For example, in the state monad the <code>(&gt;&gt;)</code> operator is just normal sequential composition, written as <code>;</code> in most languages.</p>
<p>Indeed, in Haskell the entire <code>do</code> notation, with or without <code>;</code> is just <a href="http://book.realworldhaskell.org/read/monads.html#monads.do">syntactic sugar</a> for <code>(&gt;&gt;=)</code> and <code>(&gt;&gt;)</code>. For this reason, we can legitimately say that Haskell has a <a href="https://donsbot.wordpress.com/2007/03/10/practical-haskell-shell-scripting-with-error-handling-and-privilege-separation/">programmable semicolon</a>.</p>
<h2 id="the-monad-laws">The Monad Laws</h2>
<p>Earlier we mentioned that the notion of a monad requires that the <code>return</code> and <code>(&gt;&gt;=)</code> functions satisfy some simple properties. The first two properties concern the link between <code>return</code> and <code>(&gt;&gt;=)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return x <span class="fu">&gt;&gt;=</span> f  <span class="fu">=</span>  f x  <span class="co">--  (1)</span>

mx <span class="fu">&gt;&gt;=</span> return   <span class="fu">=</span>  mx   <span class="co">--  (2)</span></code></pre></div>
<p>Intuitively, equation <code>(1)</code> states that if we return a value <code>x</code> and then feed this value into a function <code>f</code>, this should give the same result as simply applying <code>f</code> to <code>x</code>. Dually, equation <code>(2)</code> states that if we feed the results of a computation <code>mx</code> into the function <code>return</code>, this should give the same result as simply performing <code>mx</code>. Together, these equations express — modulo the fact that the second argument to <code>(&gt;&gt;=)</code> involves a binding operation — that return is the <em>left and right identity</em> for <code>(&gt;&gt;=)</code>.</p>
<p>The third property concerns the link between <code>(&gt;&gt;=)</code> and itself, and expresses (again modulo binding) that <code>(&gt;&gt;=)</code> is <em>associative</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(mx <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g  <span class="fu">=</span>  mx <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> (f x <span class="fu">&gt;&gt;=</span> g))   <span class="co">-- (3)</span></code></pre></div>
<p>Note that we cannot simply write <code>mx &gt;&gt;= (f &gt;&gt;= g)</code> on the right hand side of this equation, as this would not be type correct.</p>
<p>As an example of the utility of the monad laws, let us see how they can be used to prove a useful property of the <code>liftM</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">liftM f mx  <span class="fu">=</span> <span class="kw">do</span> { x <span class="ot">&lt;-</span> mx ; return (f x) }</code></pre></div>
<p>Namely, that it distributes over the composition operator for functions, in the sense that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">liftM (f <span class="fu">.</span> g)  <span class="fu">=</span>  liftM f <span class="fu">.</span> liftM g</code></pre></div>
<p>This equation generalises the familiar distribution property of map from lists to an arbitrary monad. In order to verify this equation, we first rewrite the definition of <code>liftM</code> using <code>(&gt;&gt;=)</code>: That is, we change the definition into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">liftM f mx  <span class="fu">=</span>  mx <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> return (f x)</code></pre></div>
<p>Now the distribution property can be verified as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(liftM f <span class="fu">.</span> liftM g) mx
   <span class="fu">=</span> <span class="co">{-   applying . -}</span>
     liftM f (liftM g mx)
   <span class="fu">=</span> <span class="co">{-   applying the second liftM -}</span>
     liftM f (mx <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> return (g x))
   <span class="fu">=</span> <span class="co">{-   applying liftM -}</span>
     (mx <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> return (g x)) <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> return (f y)
   <span class="fu">=</span> <span class="co">{-   equation (3) -}</span>
     mx <span class="fu">&gt;&gt;=</span> (\z <span class="ot">-&gt;</span> (return (g z) <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> return (f y)))
   <span class="fu">=</span> <span class="co">{-   equation (1) -}</span>
     mx <span class="fu">&gt;&gt;=</span> (\z <span class="ot">-&gt;</span> return (f (g z)))
   <span class="fu">=</span> <span class="co">{-   unapplying . -}</span>
     mx <span class="fu">&gt;&gt;=</span> (\z <span class="ot">-&gt;</span> return ((f <span class="fu">.</span> g) z)))
   <span class="fu">=</span> <span class="co">{-   unapplying liftM -}</span>
     liftM (f <span class="fu">.</span> g) mx</code></pre></div>
<p><strong>Q:</strong> Show that the maybe monad satisfies equations (1), (2) and (3).</p>
<h2 id="a-fancy-monad-example">A fancy monad example</h2>
<p>Given the type</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Exp</span> a <span class="fu">=</span> <span class="dt">EVar</span> a <span class="fu">|</span> <span class="dt">EVal</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">EAdd</span> (<span class="dt">Exp</span> a) (<span class="dt">Exp</span> a)</code></pre></div>
<p>of expressions built from variables of type <code>a</code>, show that this type is monadic by completing the following declaration:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Exp</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="co">-- fmap :: (a -&gt; b) -&gt; Exp a -&gt; Exp b</span>
<span class="ot">&gt;</span>   fmap f (<span class="dt">EVar</span> x)   <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span>
<span class="ot">&gt;</span>   fmap f (<span class="dt">EVal</span> n)   <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span>
<span class="ot">&gt;</span>   fmap f (<span class="dt">EAdd</span> x y) <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Exp</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="co">-- pure :: a -&gt; Exp a </span>
<span class="ot">&gt;</span>   pure x <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="co">-- (&lt;*&gt;) :: Exp (a -&gt; b) -&gt; Exp a -&gt; Exp b</span>
<span class="ot">&gt;</span>   ef <span class="fu">&lt;*&gt;</span> e <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Exp</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="co">-- return :: a -&gt; Expr a </span>
<span class="ot">&gt;</span>   return x <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="co">-- (&gt;&gt;=) :: Exp a -&gt; (a -&gt; Exp b) -&gt; Exp b </span>
<span class="ot">&gt;</span>   (<span class="dt">EVar</span> x)   <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span>
<span class="ot">&gt;</span>   (<span class="dt">EVal</span> n)   <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span>
<span class="ot">&gt;</span>   (<span class="dt">EAdd</span> x y) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> error <span class="st">&quot;Define me!&quot;</span></code></pre></div>
<p>Hint: think carefully about the types involved.</p>
<p><strong>Q:</strong> What does the <code>(&gt;&gt;=)</code> operator for this type do?</p>
<h2 id="further-reading">Further Reading</h2>
<p>The subject of monads is a large one, and we have only scratched the surface here. If you are interested in finding out more, two suggestions for further reading would be to look at “monads with a zero a plus” (which extend the basic notion with two extra primitives that are supported by some monads), and “monad transformers” (which provide a means to combine monads). For a more in-depth exploration of the IO monad, see Simon Peyton Jones’ excellent article on the <a href="http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/">“awkward squad”</a>.</p>
<h2 id="status-check">Status Check</h2>
<p>We saw how one can use monads in Haskell to enjoy all the benefits of imprerative programming (i.e., state and input/output) while in the back everything is functional (i.e., no side effects).</p>
<p>The benefit: the monadic type signatures explicitely capture the effects of your program since most effects are actually monads (<a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf">“The essence of functional programming”</a>). Remember from out first lecture notes: The following functions are pure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fib               ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> 
<span class="ot">allRightTriangles ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]
id<span class="ot">                ::</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>while the following have effects:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putStrLn<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">updFreqM ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">ST.State</span> (<span class="dt">MyState</span> k) ()  
<span class="ot">eval     ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Exception</span> <span class="dt">Int</span></code></pre></div>
<p>The common first application of monadic programming is parsing. For example, see sections 3 and 7 of the following article, which concerns the monadic nature of <a href="http://www.cs.nott.ac.uk/~gmh/monparsing.pdf">functional parsers</a>, where a parser is described as string (i.e., state) transformer</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(a,<span class="dt">String</span>)]</code></pre></div>
<p>To make time to discuss more about program correctness, we skip parsers and just directly to how monad combinators are used to test properties of your program (or how Ben corrected your homeworks).</p>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
