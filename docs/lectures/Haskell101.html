<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CMSC498V - Haskell101</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../index.html">Home</a>
                <a href="../schedule.html">Schelude</a>
                <a href="../homeworks.html">Homeworks</a>
                <a href="../resources.html">Resources</a>
            </div>
        </div>

        <div id="content">
            <h1 id="haskell-101-syntax">Haskell 101: Syntax</h1>
<p>Haskell is a general purpose language! This site is writen in Haskell, check the source code <a href="https://github.com/nikivazou/CMSC498V/blob/master/CMSC498V/lectures/Haskell101.lhs">here</a>!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Maybe</span> (isJust, fromJust)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Char</span>  (toLower, toUpper)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span>  (nub, nubBy)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (head, tail, (++), map, foldr, length, const)</code></pre></div>
<h2 id="recursion">Recursion</h2>
<p>Haskell is a <em>functional</em> language: supports direct encoding of mathematical functions. For example, the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci</a> definition</p>
<p><span class="math inline"><em>f</em><em>i</em><em>b</em><sub>0</sub> = 0</span> <br /><span class="math display"><em>f</em><em>i</em><em>b</em><sub>1</sub> = 1</span><br /> <span class="math inline"><em>f</em><em>i</em><em>b</em><sub><em>i</em></sub> = <em>f</em><em>i</em><em>b</em><sub><em>i</em> − 1</sub> + <em>f</em><em>i</em><em>b</em><sub><em>i</em> − 2</sub></span></p>
<p>is directly encoded as</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> fib i <span class="fu">=</span> <span class="kw">if</span> i <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> 
<span class="ot">&gt;</span>         <span class="kw">else</span> <span class="kw">if</span> i <span class="fu">==</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> 
<span class="ot">&gt;</span>         <span class="kw">else</span> fib (i<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (i<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<p>Haskell functions are like math functions: pure (side-effect free).</p>
<ul>
<li><em>advantage: </em> everytime you can a function with <em>same input</em> it returns <em>the same</em> output.</li>
<li><em>disadvantage:</em> interaction with the world is tricky.</li>
<li><em>neutral:</em> there are no loops! (only recursion)</li>
</ul>
<h2 id="running-your-code">Running your code</h2>
<p>To run the <code>fib</code> function, you can load this file to <code>ghci</code>, a Haskell interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> ghci
<span class="dt">GHCi</span>, version <span class="fl">8.0</span><span class="fu">.</span><span class="dv">2</span><span class="fu">:</span> http<span class="fu">://</span>www<span class="fu">.</span>haskell<span class="fu">.</span>org<span class="fu">/</span>ghc<span class="fu">/</span>  <span class="fu">:?</span> for help
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l Haskell101.lhs
[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span>             ( Haskell101.lhs, interpreted )
<span class="dt">Ok</span>, modules loaded<span class="fu">:</span> <span class="dt">Main</span><span class="fu">.</span></code></pre></div>
<p>You can ask <code>ghci</code> the type or further information about the loaded functions,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t fib
<span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>i fib
<span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>   <span class="co">-- Defined at Haskell101.lhs:30:1</span></code></pre></div>
<p>evaluate your code,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> fib <span class="dv">10</span>
<span class="dv">55</span></code></pre></div>
<p>make new definitions (that went fast!),</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="kw">let</span> fib42 <span class="fu">=</span> fib <span class="dv">42</span></code></pre></div>
<p>or quit.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>q
<span class="dt">Leaving</span> <span class="dt">GHCi</span><span class="fu">.</span></code></pre></div>
<p><strong>Q:</strong> Is <code>fib 42</code> actually evaluated in the above definition?</p>
<h2 id="syntax-guards">Syntax: Guards</h2>
<p>Guards provide an alternative syntax for <em>if</em> expressions. The body of the <em>first</em> guard that is evaluated to true is returned.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fib1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> fib1 i 
<span class="ot">&gt;</span>   <span class="fu">|</span> i <span class="fu">==</span> <span class="dv">0</span> <span class="fu">||</span> i <span class="fu">==</span> <span class="dv">1</span>
<span class="ot">&gt;</span>   <span class="fu">=</span> i 
<span class="ot">&gt;</span>   <span class="fu">|</span> otherwise 
<span class="ot">&gt;</span>   <span class="fu">=</span> fib1 (i<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib1 (i<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<p><strong>Note:</strong> No <code>=</code> before the guards!</p>
<h2 id="syntax-case-analysis">Syntax: Case Analysis</h2>
<p>Another alternative syntax is using <code>case</code> analysis:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fib2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> fib2 i <span class="fu">=</span> <span class="kw">case</span> i <span class="kw">of</span> 
<span class="ot">&gt;</span>           <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dv">0</span>
<span class="ot">&gt;</span>           <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">1</span> 
<span class="ot">&gt;</span>           i <span class="ot">-&gt;</span> fib2 (i<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib2 (i<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<p><strong>The golden rule of indentation:</strong> Code which is part of some expression should be indented further in than the beginning of that expression (even if the expression is not the leftmost element of the line).</p>
<p>Violations of this rule lead to syntax error!</p>
<h2 id="syntax-pattern-matching">Syntax: Pattern Matching</h2>
<p>A final equivalent syntax is pattern matching:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fib3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> fib3 <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span> 
<span class="ot">&gt;</span> fib3 <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span> 
<span class="ot">&gt;</span> fib3 i <span class="fu">=</span> fib3 (i<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib3 (i<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<p><strong>Evaluation order</strong> is from top to bottom.</p>
<p><strong>Q:</strong> What happens if the recursive <code>fib3 i</code> case is defined first?</p>
<p><strong>Q:</strong> What is the value of <code>fib</code> on negative inputs?</p>
<h2 id="data-types">Data Types</h2>
<p>Data types classify data for two main purposes.</p>
<p><strong>Purpose 1:</strong> Specification to the programmer of the permitted set of operations.</p>
<ul>
<li><code>Int</code>: case analysis, numeric operations (<code>(+)</code>, <code>(-)</code>, …)</li>
<li><code>Double</code>: case analysis, numeric operations (<code>(/)</code>, …)</li>
<li><code>Char</code>: case analysis, <code>Data.Char.isUpper</code>, …</li>
</ul>
<p><strong>Purpose 2:</strong> Specification to the compiler how the programmer intends to use the data.</p>
<ul>
<li><code>Int</code> is the type of machine integers, with guaranteed range at least -<span class="math inline">2<sup>29</sup></span> to <span class="math inline">2<sup>29</sup> − 1</span>.</li>
<li><code>Integer</code> is arbitrary precision integers, with range as large as you have memory for.</li>
</ul>
<p>Adding <code>1</code> to the largest <code>Int</code> will give an overflow.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">maxBound<span class="ot"> ::</span> <span class="dt">Int</span> 
<span class="dv">9223372036854775807</span>

(maxBound <span class="fu">+</span> <span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Int</span> 
<span class="fu">-</span><span class="dv">9223372036854775808</span></code></pre></div>
<h2 id="user-defined-data-types">User Defined Data Types</h2>
<p>Users can comlibe data together and provide more operations to them. For example, the data <code>IntError</code> combines integer values with <code>Error</code> string.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">IntError</span> 
<span class="ot">&gt;</span>   <span class="fu">=</span> <span class="dt">Value</span> {<span class="ot">val ::</span> <span class="dt">Int</span>} 
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">Error</span> {<span class="ot">err ::</span> <span class="dt">String</span>} </code></pre></div>
<p>Every user defined data type comes with three operations</p>
<ul>
<li><strong>Construction:</strong> How to construct such the data type</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Value</span> <span class="dv">42</span><span class="ot">          ::</span> <span class="dt">IntError</span> 
<span class="dt">Error</span> <span class="st">&quot;Not Valid&quot;</span><span class="ot"> ::</span> <span class="dt">IntError</span></code></pre></div>
<ul>
<li><strong>Selection:</strong> Select value from data type</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> val (<span class="dt">Value</span> <span class="dv">42</span>)
<span class="dv">42</span>

<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> err (<span class="dt">Value</span> <span class="dv">42</span>)
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">No</span> match <span class="kw">in</span> record selector err</code></pre></div>
<ul>
<li><strong>Case Analysis:</strong> How to deconstruct the content of the data</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">case</span> val <span class="kw">of</span>
  <span class="dt">Value</span> i <span class="ot">-&gt;</span> i <span class="fu">+</span> <span class="dv">42</span>
  <span class="dt">Error</span> s <span class="ot">-&gt;</span> error e</code></pre></div>
<p>We use <code>IntError</code> to return <code>Error</code> when <code>fib</code> is called on negative numbers.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fibError ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IntError</span>
<span class="ot">&gt;</span> fibError <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Value</span> <span class="dv">0</span> 
<span class="ot">&gt;</span> fibError <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Value</span> <span class="dv">1</span>     <span class="co">-- construction</span>
<span class="ot">&gt;</span> fibError i <span class="fu">|</span> i <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Error</span> (show i) 
<span class="ot">&gt;</span> fibError i <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="kw">case</span> fibError (i<span class="fu">-</span><span class="dv">1</span>) <span class="kw">of</span> <span class="co">-- case analysis </span>
<span class="ot">&gt;</span>     <span class="dt">Value</span> j <span class="ot">-&gt;</span> <span class="kw">case</span> fibError (i<span class="fu">-</span><span class="dv">2</span>) <span class="kw">of</span> 
<span class="ot">&gt;</span>                  <span class="dt">Value</span> k <span class="ot">-&gt;</span> <span class="dt">Value</span> (j<span class="fu">+</span>k)
<span class="ot">&gt;</span>                  <span class="dt">Error</span> s <span class="ot">-&gt;</span> <span class="dt">Error</span> s 
<span class="ot">&gt;</span>     <span class="dt">Error</span> s <span class="ot">-&gt;</span> <span class="dt">Error</span> s </code></pre></div>
<h2 id="maybe-data-type">Maybe Data Type</h2>
<p><code>IntError</code> is similar to Haskell’s <code>Maybe</code> data type that has two constructors <code>Just</code> and <code>Nothing</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fibMaybe' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> fibMaybe' i <span class="fu">=</span> fromJust (fibMaybe i)
<span class="ot">&gt;</span> 
<span class="ot">&gt; fibMaybe ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> fibMaybe i <span class="fu">|</span> i <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> fibMaybe <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">0</span> 
<span class="ot">&gt;</span> fibMaybe <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">1</span> 
<span class="ot">&gt;</span> fibMaybe i <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="kw">case</span> fibMaybe (i<span class="fu">-</span><span class="dv">1</span>) <span class="kw">of</span> 
<span class="ot">&gt;</span>     <span class="dt">Just</span> j  <span class="ot">-&gt;</span> <span class="kw">case</span> fibMaybe (i<span class="fu">-</span><span class="dv">2</span>) <span class="kw">of</span> 
<span class="ot">&gt;</span>                 <span class="dt">Just</span> k  <span class="ot">-&gt;</span> <span class="dt">Just</span> (j<span class="fu">+</span>k)
<span class="ot">&gt;</span>                 <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span> 
<span class="ot">&gt;</span>     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></code></pre></div>
<p><strong>Q:</strong> What is an advantage of using <code>Maybe</code> instead of user-defined <code>IntError</code>?</p>
<h2 id="lists">Lists</h2>
<p>List is the most famous Haskell data type with two constructors</p>
<ul>
<li>the <em>empty</em> list <code>[]</code> and</li>
<li>the <em>cons</em> operator <code>:</code>.</li>
</ul>
<h2 id="toy-list-construction">Toy List Construction</h2>
<p>List construction happens via these two constructors!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">3</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>[]<span class="ot">   ::</span> [<span class="dt">Int</span>] 
[<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]<span class="ot">  ::</span> [<span class="dt">Int</span>] <span class="co">-- simplification</span></code></pre></div>
<p>Lists can contain any values</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dt">True</span>]<span class="ot">                 ::</span> [<span class="dt">Bool</span>]
[<span class="ch">'c'</span>, <span class="ch">'h'</span>, <span class="ch">'a'</span>, <span class="ch">'r'</span>]<span class="ot">   ::</span> [<span class="dt">Char</span>] 
<span class="st">&quot;char&quot;</span><span class="ot">                 ::</span> <span class="dt">String</span>
[<span class="dt">Value</span> <span class="dv">9</span>, <span class="dt">Error</span> <span class="st">&quot;pff&quot;</span>]<span class="ot"> ::</span> [<span class="dt">IntError</span>]</code></pre></div>
<p><strong>Q:</strong> What is the type of the empty list?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[]<span class="ot"> ::</span> <span class="fu">??</span></code></pre></div>
<p><strong>Q:</strong> Is there a type for the cons constructor too?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(:) ::</span> <span class="fu">??</span> </code></pre></div>
<p>Case analysis uses the list constructors</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">listCase ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
listCase xs <span class="fu">=</span> 
  <span class="kw">case</span> xs <span class="kw">of</span> 
    []      <span class="ot">-&gt;</span> <span class="dv">1</span> 
    [<span class="dv">2</span>]     <span class="ot">-&gt;</span> <span class="dv">2</span>
    [x,y,z] <span class="ot">-&gt;</span> <span class="dv">3</span>
    x<span class="fu">:</span>xs    <span class="ot">-&gt;</span> <span class="dv">4</span>
    [x,y]   <span class="ot">-&gt;</span> <span class="dv">5</span> </code></pre></div>
<p><strong>Q:</strong> What is the value of <code>listCase [2, 6]</code>?</p>
<h2 id="list-comprehension">List Comprehension</h2>
<p>Due to its popularity, list manipulation is greatly simplified by list comprehensions.</p>
<ul>
<li>List range</li>
</ul>
<p><code>[lo .. hi]</code> gives the list of values from <code>lo</code> to <code>hi</code>.</p>
<p>For example, <code>[1..10]</code> gives the list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code> and <code>['a'..'z']</code> gives “abcdefghijklmnopqrstuvwxyz”!</p>
<ul>
<li>Filterning</li>
</ul>
<p>Ranges can be filtered with predicates that go after the range.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> evens <span class="fu">=</span> [x <span class="fu">|</span> x<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>],  x <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">0</span>]</code></pre></div>
<p>With this we can solve many <a href="https://projecteuler.net/archives">Project Euler</a> problems!</p>
<p><strong>Q:</strong> <a href="https://projecteuler.net/problem=1">Problem 1</a> of Project Euler asks for the sum of all the multiples of 3 or 5 below 1000.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; problem1 ::</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> problem1 <span class="fu">=</span> sum (helper <span class="dv">1</span> <span class="dv">999</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> problem1' <span class="fu">=</span> [x <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">999</span>], mod x <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span> <span class="fu">||</span> mod x <span class="dv">5</span> <span class="fu">==</span> <span class="dv">0</span>]
<span class="ot">&gt;</span> helper lo hi 
<span class="ot">&gt;</span>   <span class="fu">|</span> lo <span class="fu">&gt;=</span> hi <span class="fu">=</span> [] 
<span class="ot">&gt;</span>   <span class="fu">|</span> lo <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span> <span class="fu">||</span> lo <span class="ot">`mod`</span> <span class="dv">5</span> <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> lo<span class="fu">:</span>helper (lo<span class="fu">+</span><span class="dv">1</span>) hi
<span class="ot">&gt;</span>   <span class="fu">|</span> otherwise                          <span class="fu">=</span>  helper (lo<span class="fu">+</span><span class="dv">1</span>) hi</code></pre></div>
<ul>
<li>Pairs</li>
</ul>
<p>List comprehensions can compile elements from different ranges</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> pairs <span class="fu">=</span> [(x,y) <span class="fu">|</span> x<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>], y<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]]</code></pre></div>
<p>For example, <code>triangles</code> give all possible triangles with sizes less than <code>10</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> triangles <span class="fu">=</span> [(x,y,z) <span class="fu">|</span> x<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>], y<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>], z<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]]</code></pre></div>
<p>We can get only the right triangles by adding the pythagorean constraint. For <em>efficiency</em> we search only for sides <code>x</code> and <code>y</code> that are not greater than the hypotenuse.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> rightTriangles 
<span class="ot">&gt;</span>   <span class="fu">=</span> [(x,y,z) <span class="fu">|</span> z<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>], y<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span>z], x<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span>y]
<span class="ot">&gt;</span>              , x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> y<span class="fu">^</span><span class="dv">2</span> <span class="fu">==</span> z<span class="fu">^</span><span class="dv">2</span>]</code></pre></div>
<p><strong>Q:</strong> The triangle <code>(4,3,5)</code> appears twice as <code>(4,3,5)</code> and <code>(3,4,5)</code>. How do we filter such duplication?</p>
<p>Finally, we parameterize the right triangle generation on the length of the hypotenuse to get all right triangles with length up to <code>n</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> allRightTriangles n 
<span class="ot">&gt;</span>   <span class="fu">=</span> [(x,y,z) <span class="fu">|</span> z<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span>n], y<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span>z], x<span class="ot">&lt;-</span>[<span class="dv">1</span><span class="fu">..</span>y]
<span class="ot">&gt;</span>              , x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> y<span class="fu">^</span><span class="dv">2</span> <span class="fu">==</span> z<span class="fu">^</span><span class="dv">2</span>]</code></pre></div>
<h2 id="recursion-on-lists">Recursion on Lists</h2>
<p>List comprehension is great but most of the times we need to use traditional recursion to define functions on lists.</p>
<ul>
<li>Getting the length of a list</li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; length ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> length []     <span class="fu">=</span> <span class="dv">0</span> 
<span class="ot">&gt;</span> length (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> length xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">length [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>] <span class="fu">=</span> <span class="dv">4</span>
length []           <span class="fu">=</span> <span class="dv">0</span>
length <span class="st">&quot;string&quot;</span>     <span class="fu">=</span> <span class="dv">6</span></code></pre></div>
<p><strong>Note:</strong> <code>length</code> is <em>polymorphic</em> it operates on lists of every type.<br />
<strong>Note:</strong> In <code>Haskell</code> the <code>length</code> function is defined in <code>Prelude</code>, that is the module that contain all the basic functions and data definitions and is by default loaded. If you want to redefine functions in <code>Prelude</code> you need to explicitly hide the default ones. Look at the beginning of this file to see how indeed we hide the <code>Prelude.length</code>.</p>
<ul>
<li>Getting the head of a list</li>
</ul>
<p>The function <code>head</code> returns the head of the list. <code>head</code> is <em>partial</em> that is, it is not defined in all list inputs as it crashes on empty lists.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; head ::</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> head (x<span class="fu">:</span>_) <span class="fu">=</span> x
<span class="ot">&gt;</span> head []    <span class="fu">=</span> error <span class="st">&quot;head on empty list&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> head <span class="st">&quot;Haskell&quot;</span>
<span class="ch">'H'</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> head []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> head on empty list
<span class="dt">CallStack</span> (from <span class="dt">HasCallStack</span>)<span class="fu">:</span>
 error, called at Haskell101.lhs<span class="fu">:</span><span class="dv">391</span><span class="fu">:</span><span class="dv">14</span> <span class="kw">in</span> main<span class="fu">:</span><span class="dt">Main</span></code></pre></div>
<p>We can just delete the error case from the list definition and Haskell will insert a default error call for us!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; head' ::</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> head' (x<span class="fu">:</span>_) <span class="fu">=</span> x</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> head' <span class="st">&quot;Haskell&quot;</span>
<span class="ch">'H'</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> head' []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Haskell101.lhs<span class="fu">:</span><span class="dv">406</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">15</span><span class="fu">:</span> <span class="dt">Non</span><span class="fu">-</span>exhaustive patterns <span class="kw">in</span> function head'</code></pre></div>
<p><strong>Note on polymorphism:</strong> The function <code>error</code> is suspicious and we can see it from its type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">error<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a </code></pre></div>
<p>It returns any value <code>a</code>. In the <code>head</code> definition <code>a</code> is unified with a list.</p>
<p><em>The rule of polymorphism</em> is that every function that returns a type variable not appearing in its arguments will crash.</p>
<p>For example, you can define a non-crashing functions that takes two arguments of type <code>a</code> and <code>b</code> and returns a <code>b</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; const ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b 
<span class="ot">&gt;</span> const    <span class="fu">=</span> challenge</code></pre></div>
<p>Now, try to define a non-crashing function that takes two arguments of type <code>a</code> and <code>b</code> and returns a <code>c</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; challenge ::</span> a1 <span class="ot">-&gt;</span> b1 <span class="ot">-&gt;</span> c1
<span class="ot">&gt;</span> challenge   x y  <span class="fu">=</span> error <span class="st">&quot;&quot;</span> </code></pre></div>
<p>Back to recursive list functions, let’s take the tail of a list!</p>
<p><strong>Q:</strong> Define the tail of a list</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">tail <span class="st">&quot;Yeah Haskell!&quot;</span> <span class="fu">=</span> <span class="st">&quot;eah Haskell!&quot;</span>
tail [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]  <span class="fu">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tail ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> tail (x<span class="fu">:</span>xs) <span class="fu">=</span> xs </code></pre></div>
<p><strong>Q:</strong> Concatenate two lists</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">concat <span class="st">&quot;?eah &quot;</span>   <span class="st">&quot;Haskell!!!!!&quot;</span> <span class="fu">=</span> <span class="st">&quot;?eah Haskell!!!!!&quot;</span>
concat  [<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>] [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]   <span class="fu">=</span> [<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; concat' ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> concat' [] ys <span class="fu">=</span> ys 
<span class="ot">&gt;</span> <span class="co">-- concat' xs [] = xs </span>
<span class="ot">&gt;</span> concat' (x<span class="fu">:</span>xs) ys <span class="fu">=</span> x<span class="fu">:</span>(concat' xs ys)</code></pre></div>
<p><strong>Note on infix operators</strong>. The default list concatenation operator in Haskell is the infix <code>(++)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;?eah&quot;</span>   <span class="fu">++</span>  <span class="st">&quot;Haskell!!!!!&quot;</span> <span class="fu">=</span> <span class="st">&quot;?eah Haskell!!!!!&quot;</span>
[<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>]  <span class="fu">++</span>  [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]   <span class="fu">=</span> [<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</code></pre></div>
<p>The infix <code>(++)</code> is defined as follows</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> [] <span class="fu">++</span> ys     <span class="fu">=</span> ys
<span class="ot">&gt;</span> (x<span class="fu">:</span>xs) <span class="fu">++</span> ys <span class="fu">=</span> x<span class="fu">:</span>(xs <span class="fu">++</span> ys)</code></pre></div>
<p>Every infix operator becomes prefix is you wrap it in parenthesis</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">++</span>) <span class="st">&quot;?eah&quot;</span>  <span class="st">&quot;Haskell!!!!!&quot;</span> <span class="fu">=</span> <span class="st">&quot;?eah Haskell!!!!!&quot;</span>
(<span class="fu">++</span>) [<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>] [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]   <span class="fu">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</code></pre></div>
<p>The other way, every prefix operator becomes infix if you wrap it in “`”. For example the <code>elem x xs</code> function that checks if <code>x</code> is an element of the list <code>xs</code> can be used as infix</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> elem  <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
<span class="dt">True</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="ot">`elem`</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
<span class="dt">True</span></code></pre></div>
<h2 id="computation-patters-mapping">Computation Patters: mapping</h2>
<p>Let’s write a function that converts a string to uppercase. Recall that in Haskell, a String is just a list of Char. We must start with a function that will convert an individual Char to its uppercase version. Once we find this function, we will simply jog over the list, and apply the function to each Char.</p>
<p>How might we find such a transformer? Lets query Hoogle for a function of the appropriate type! Ah, we see that the module Data.Char contains a function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">toLower<span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span></code></pre></div>
<p>and so now, we can write the simple recursive function</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toLowerString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
toLowerString []     <span class="fu">=</span> []
toLowerString (c<span class="fu">:</span>cs) <span class="fu">=</span> toLower c <span class="fu">:</span> toLowerString cs</code></pre></div>
<p>Lets now write a function that given a list of integers increases each of its elements by 1</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">plusOneList ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
plusOneList []     <span class="fu">=</span> []
plusOneList (n<span class="fu">:</span>ns) <span class="fu">=</span> (n<span class="fu">+</span><span class="dv">1</span>) <span class="fu">:</span> plusOneList ns</code></pre></div>
<p>Now, in a lesser language, you might be quite happy with the above code. But what separates a good programmer from a great one, is the ability to abstract.</p>
<p>Like humans and monkeys, the functions <code>toLowerString</code> and <code>plusOneList</code> share 93% of their DNA — the notion of jogging over the list. The common pattern is described by the polymorphic higher-order function map</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> map f []     <span class="fu">=</span> []
<span class="ot">&gt;</span> map f (x<span class="fu">:</span>xs) <span class="fu">=</span> (f x) <span class="fu">:</span> (map f xs)</code></pre></div>
<p>How did we arrive at this? Well, you find what is enshrine in the function’s body that which is common to the different instances, namely the recursive jogging strategy; and the bits that are different, simply become the function’s parameters! Thus, the map function abstracts, or if you have a vivid imagination, locks up in a bottle, the extremely common pattern of jogging over the list.</p>
<p>Verily, the type of map tells us exactly what it does</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; map ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</code></pre></div>
<p>That is, it takes an <code>a -&gt; b</code> transformer and list of a values, and transforms each value to return a list of b values. We can now safely reuse the pattern, by instantiating the transformer with different specific operations.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> toLowerString <span class="fu">=</span> map toLower
<span class="ot">&gt;</span> plusOneList   <span class="fu">=</span> map (<span class="fu">+</span><span class="dv">1</span>)</code></pre></div>
<p>Much better.</p>
<h2 id="computation-pattern-folding">COMPUTATION PATTERN: FOLDING</h2>
<p>Once you’ve put on the FP goggles, you start seeing computation patterns everywhere.</p>
<p>Lets write a function that adds all the elements of a list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">listAdd []     <span class="fu">=</span> <span class="dv">0</span>
listAdd (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> (listAdd xs)</code></pre></div>
<p>Next, a function that multiplies the elements of a list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">listMul []     <span class="fu">=</span> <span class="dv">1</span>
listMul (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">*</span> (listMul xs)</code></pre></div>
<p>Can you see the pattern? Again, the only bits that are different are the base case value, and the op being performed at each step. We’ll just turn those into parameters, and lo!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> foldr op base []     <span class="fu">=</span> base
<span class="ot">&gt;</span> foldr op base (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="ot">`op`</span> (foldr op base xs) </code></pre></div>
<p>Now, each of the individual functions are just specific instances of the general foldr pattern.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> listAdd <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span>
<span class="ot">&gt;</span> listMul <span class="fu">=</span> foldr (<span class="fu">*</span>) <span class="dv">1</span></code></pre></div>
<p>To develop some intuition about foldr lets “run” it a few times by hand.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr op base [x1,x2,<span class="fu">...</span>,xn] 
<span class="fu">==</span> <span class="co">{- unfold -}</span> 
   x1 <span class="ot">`op`</span> (foldr op base [x2,<span class="fu">...</span>,xn])
<span class="fu">==</span> <span class="co">{- unfold -}</span> 
   x1 <span class="ot">`op`</span> (x2 <span class="ot">`op`</span> (foldr op base [<span class="fu">...</span>,xn]))
<span class="fu">==</span> <span class="co">{- unfold -}</span> 
   x1 <span class="ot">`op`</span> (x2 <span class="ot">`op`</span> (<span class="fu">...</span> <span class="ot">`op`</span> (xn <span class="ot">`op`</span> base)))</code></pre></div>
<p>Aha! It has a rather pleasing structure that mirrors that of lists; the : is replaced by the op and the <code>[]</code> is replaced by <code>base</code>. Thus, can you see how to use it to eliminate recursion from the recursion from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">listLen []     <span class="fu">=</span> <span class="dv">0</span>
listLen (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (listLen xs)</code></pre></div>
<p>to define list length in one line.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> listLen xs <span class="fu">=</span> foldr (\_ tailLen <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> tailLen) <span class="dv">0</span> xs</code></pre></div>
<p><strong>Let’s Haskell it up!</strong> (a.k.a. make <code>listLen</code> shorter but almost unreadable…)</p>
<ul>
<li><em>Step 1:</em> Arguments that appear only at the end of the definition can be deleted</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">listLen <span class="fu">=</span> foldr (\_ tailLen <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> tailLen) <span class="dv">0</span> </code></pre></div>
<ul>
<li><em>Step 2:</em> Unused arguments can be simplified with <code>const :: a -&gt; b -&gt; a</code>. The function <code>const</code> just consumes the second unused argument <code>b</code>!</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">listLen <span class="fu">=</span> foldr (const (\tailLen <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> tailLen)) <span class="dv">0</span> </code></pre></div>
<ul>
<li><em>Step 3:</em> Back to Step 1 on <code>tailLen</code> :)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">listLen <span class="fu">=</span> foldr (const (<span class="dv">1</span><span class="fu">+</span>)) <span class="dv">0</span> </code></pre></div>
<h2 id="higher-order-haskell-dialect">Higher-Order Haskell dialect</h2>
<p>We call <code>map</code> and <code>foldr</code> higher order functions because they accept function arguments. To better understand higher order programming, lets play with Haskell’s most common functions, the dollar and the dot.</p>
<p>Haskell dislikes parethensis so much that has a (very commonly used) operator merely to remove parenthesis. The ‘$’ operator is used to remove parenthesis at the last argument of functions. For example</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">take <span class="dv">5</span> (map (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>])</code></pre></div>
<p>is writen as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">take <span class="dv">5</span> <span class="fu">$</span> map (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre></div>
<p>The cool part: ‘$’ is a Haskell function defined in the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#%24"><code>Prelude</code></a> as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">($)   ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
f <span class="fu">$</span> x <span class="fu">=</span>  f x</code></pre></div>
<p>with a fixity annotation that gives it higher precedence than function application!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">0</span>  <span class="fu">$</span></code></pre></div>
<p>The cooler part: you can (ab)use dollar to apply a constant <code>x</code> to a function, for every function!</p>
<p><strong>Q:</strong> What is the type of <code>($ &quot;me!&quot;)</code>?</p>
<p><strong>Q:</strong> What is the result of <code>map ($ &quot;me!&quot;) [map toUpper , (++&quot;!?!?!&quot;)]</code>?</p>
<p>The coolest part: you can define your own dollar-like functions For instance, we can define the <code>(•)</code> operator to with a strong left precedence (that is, stronger than function application)</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">infixl</span> <span class="dv">0</span> •
<span class="ot">&gt;</span> (•)<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> f • x <span class="fu">=</span> f x </code></pre></div>
<p>Now we can remove all the argument parenthesis and intead create argument lists!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fourArgs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> 
<span class="ot">&gt;</span> fourArgs x1 x2 x3 x4 <span class="fu">=</span> x1 <span class="fu">++</span> x2 <span class="fu">++</span> x3 <span class="fu">++</span> x4 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> argList <span class="fu">=</span> fourArgs 
<span class="ot">&gt;</span>            • <span class="st">&quot;Now I can list my arguments!&quot;</span>
<span class="ot">&gt;</span>            • map toUpper <span class="st">&quot;I am the second Argument!&quot;</span>
<span class="ot">&gt;</span>            • map toLower <span class="st">&quot;Argument List !!!&quot;</span>
<span class="ot">&gt;</span>            • map toUpper <span class="st">&quot;Final Argument&quot;</span> <span class="fu">++</span> <span class="st">&quot;!!!&quot;</span></code></pre></div>
<p>The second famous Haskell operator is <code>(.)</code> for function composition.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
f <span class="fu">.</span> g x <span class="fu">=</span> f (g x)</code></pre></div>
<p>For example, adding first <code>1</code> and then <code>4</code> to an argument adds <code>5</code> to the argument!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="kw">let</span> plus5 <span class="fu">=</span> (<span class="fu">+</span><span class="dv">4</span>) <span class="fu">.</span> (<span class="fu">+</span><span class="dv">1</span>) 
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> plus5 <span class="dv">0</span> 
<span class="dv">5</span></code></pre></div>
<p>Not so interesting… Lets compose more interesting functions!</p>
<p>We start with a function that checks greater than <code>1</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">&gt;</span><span class="dv">1</span>)
(<span class="fu">&gt;</span><span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> (<span class="fu">&gt;</span><span class="dv">1</span>) <span class="dv">0</span>
<span class="dt">False</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> (<span class="fu">&gt;</span><span class="dv">1</span>) <span class="dv">2</span>
<span class="dt">True</span></code></pre></div>
<p>We compose the above function once:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t ((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>)
((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>)<span class="ot"> ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> ((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>) (<span class="fu">+</span><span class="dv">42</span>) <span class="dv">1</span>
<span class="dt">True</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> ((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>) (<span class="fu">+</span><span class="dv">42</span>) (<span class="fu">-</span><span class="dv">90</span>)
<span class="dt">False</span></code></pre></div>
<p>And compose it again!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t (((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>)<span class="fu">.</span>)
(((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>)<span class="fu">.</span>)<span class="ot"> ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> (((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>)<span class="fu">.</span>) (<span class="fu">+</span>) <span class="dv">1</span> <span class="dv">2</span>
<span class="dt">True</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> (((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>)<span class="fu">.</span>) (<span class="fu">+</span>) <span class="dv">1</span> <span class="dv">0</span>
<span class="dt">False</span></code></pre></div>
<p>We can now define a function <code>isFactor x y</code> that checks if <code>x</code> is a factor of <code>y</code></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isFactor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> 
<span class="ot">&gt;</span> isFactor <span class="fu">=</span> (((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>)<span class="fu">.</span>gcd)</code></pre></div>
<p>Lets close it up by using <code>isFactor</code> to find out all the prime numbers!</p>
<p>The list function <code>nub</code> filters out all the list duplicates</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nub ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] 
nub [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]
[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<p>The list function <code>nubBy</code> uses a user specified predicate to filter out list elements</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nubBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) [a] <span class="ot">-&gt;</span> [a] 
nubBy (<span class="fu">&lt;</span>) [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]
[<span class="dv">1</span>, <span class="dv">1</span>]</code></pre></div>
<p>When the nub predicate is <code>isFactor</code> then we get back only prime numbers!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> primes <span class="fu">=</span> nubBy (((<span class="fu">&gt;</span><span class="dv">1</span>)<span class="fu">.</span>)<span class="fu">.</span>gcd) [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>]</code></pre></div>
<h2 id="interaction-with-the-real-world">Interaction with the real world</h2>
<p>Now you have learned everything you need to write basic Haskell programs. But, if Haskell programs are pure (i.e., same input always gives same output) wouldn’t Haskell programs be obsolete? Programs make sense only when they returned (or <em>output</em>) different results, depending on some user <em>input</em>.</p>
<p>Haskell carefully allows interaction with the real world (input and output) on computations inside the “IO monad”.</p>
<p>A function with a “normal” result type is pure. For example none of the following functions can depend on the outside world</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fib               ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> 
<span class="ot">allRightTriangles ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]
id<span class="ot">                ::</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>Functions that return a value wrapped in <code>IO</code> clearly state their dependence on the input and output world. For example <code>putStrLn</code> outputs its input string and <code>getLine</code> gets an input string from the user.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putStrLn<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
getLine<span class="ot">  ::</span> <span class="dt">IO</span> <span class="dt">String</span> </code></pre></div>
<p>Using the above functions we can ask the user for an integer input, compute the <code>allRightTriangles</code> of that input and output the result.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   putStrLn <span class="st">&quot;Hello there!&quot;</span> 
<span class="ot">&gt;</span>   putStrLn <span class="st">&quot;What right triangle are you looking for? &quot;</span>
<span class="ot">&gt;</span>   i <span class="ot">&lt;-</span> getLine 
<span class="ot">&gt;</span>   <span class="kw">let</span> triangles <span class="fu">=</span> allRightTriangles (read i)
<span class="ot">&gt;</span>   putStrLn (show triangles)</code></pre></div>
<p>All <code>IO</code> computations are written inside a <code>do</code> notation where there are two kind of defined variable</p>
<ul>
<li>pure that are defined using <code>let</code> and</li>
<li>impure defined using <code>&lt;-</code>.</li>
</ul>
<p>Doesn’t <code>IO</code> break Haskell’s purity? No! All impure computations are carefully wrapped in the <code>IO</code> monad! Also, Impure <code>IO</code> functions can call pure mathematical functions but not the inverse, enforcing a clear separation of the purity boundaries.</p>
<h2 id="compiling-your-code">Compiling your code</h2>
<p>After adding interaction with the user, this file can be compiled to create an executable program!</p>
<p>Compilation of this file happens with the following command.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghc Haskell101.lhs <span class="co">--make</span></code></pre></div>
<p>that creates the <code>Haskell101</code> executable. The executable runs the <code>main :: IO ()</code> function that here computes all the right triangles!</p>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
